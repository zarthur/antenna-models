import numpy as np
import pandas as pd

# generated by ChatGPT-4o
# https://chatgpt.com/share/21ec29e5-2c74-430b-846b-7d5b80b9d72b

def generate_antenna_geometry_4nec2(frequency, pipe_radius=0.075, wire_radius=0.001, segments_per_turn=21):
    # Constants
    c = 299792458  # Speed of light in m/s
    
    # Calculate the wavelength and dipole length
    wavelength = c / frequency
    dipole_length = wavelength / 2
    
    # Calculate the circumference of the pipe
    pipe_circumference = 2 * np.pi * pipe_radius
    
    # Calculate the number of turns based on available wire length
    turns = dipole_length / pipe_circumference
    total_segments = int(turns * segments_per_turn)
    
    # Angles for each segment
    angles = np.linspace(0, 2 * np.pi * turns, total_segments)
    segment_length = dipole_length / total_segments
    
    # Initialize lists for geometry data
    tags = list(range(1, total_segments + 1))  # Incrementing tags starting from 1
    segs = [segments_per_turn] * total_segments
    x1 = []
    y1 = []
    z1 = []
    x2 = []
    y2 = []
    z2 = []
    radii = [wire_radius] * total_segments
    
    # Generating geometry values for each segment
    for i in range(total_segments):
        # Calculate start and end points of each segment
        x_start = pipe_radius * np.cos(angles[i])
        y_start = pipe_radius * np.sin(angles[i])
        z_start = i * segment_length - dipole_length / 2
        
        if i < total_segments - 1:
            x_end = pipe_radius * np.cos(angles[i + 1])
            y_end = pipe_radius * np.sin(angles[i + 1])
            z_end = (i + 1) * segment_length - dipole_length / 2
        else:
            # For the last segment, wrap to the end of the dipole
            x_end = pipe_radius * np.cos(angles[0])
            y_end = pipe_radius * np.sin(angles[0])
            z_end = dipole_length / 2
        
        # Append values to the lists
        x1.append(x_start)
        y1.append(y_start)
        z1.append(z_start)
        x2.append(x_end)
        y2.append(y_end)
        z2.append(z_end)
    
    # Create a DataFrame for the geometry data
    geometry_df = pd.DataFrame({
        'Type': ['GW'] * total_segments,
        'Tag': tags,
        'Segs': segs,
        'x1': x1,
        'y1': y1,
        'z1': z1,
        'x2': x2,
        'y2': y2,
        'z2': z2,
        'Radius': radii
    })
    
    return geometry_df

def generate_nec_geometry_lines(geometry_df):
    # Format each row into a NEC-compatible 'GW' line
    nec_lines = []
    for _, row in geometry_df.iterrows():
        line = (
            f"GW {row['Tag']:>3} {row['Segs']:>3} "
            f"{row['x1']:>10.6f} {row['y1']:>10.6f} {row['z1']:>10.6f} "
            f"{row['x2']:>10.6f} {row['y2']:>10.6f} {row['z2']:>10.6f} "
            f"{row['Radius']:>10.6f}"
            "\n"
        )
        nec_lines.append(line)
    
    return nec_lines

